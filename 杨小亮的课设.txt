#include <graphics.h>
#include <math.h>
#include<windows.h>
#include <stdlib.h>
#include <conio.h>
#include<stdio.h>
#include<time.h> 
#pragma comment(lib,"Winmm.lib")
#define RANDOM(m,n) (rand()%((n+1)-(m)) + (m))
#define GEN_VALUE() RANDOM(1, 9)
#define GEN_VALUE1() RANDOM(1, 9)
#define GEN_VALUE2() RANDOM(0, 3)
#define GEN_VALUE3() RANDOM(0, 3)
#define WIDTH 640
#define LENGTH 480
int limit = (WIDTH*LENGTH) / (WIDTH + LENGTH);
int xA = (WIDTH*LENGTH) / (WIDTH + LENGTH);
int yA = (WIDTH*LENGTH) / (WIDTH + LENGTH);
int xB = (WIDTH*WIDTH) / (WIDTH + LENGTH);
int yB = (LENGTH*LENGTH) / (WIDTH + LENGTH);
IMAGE bkimg;
typedef struct node {
	int m;
	int n;
	char v;
	struct node* next;
}node;//结构体与链表
//绘制进入游戏动画
void GameCinematic1();

void GameCinematic2();

void GameCinematic3();

void CLOSE();//绘制退出游戏动画

int jiemian();//进入游戏的界面：游戏帮助、开始游戏、退出游戏、打开音乐

void introduction();//游戏说明也即游戏介绍

void huanying();//欢迎玩家界面

void hit(IMAGE img1, IMAGE img2, char* str);//设置鼠标点击进入下一个程序块

void playername(char* z);//获取玩家用户名

void music();//添加音乐

void background1(IMAGE img1, IMAGE img2, char* a);//背景一，游戏开始后界面，有暂停按钮

void background2(IMAGE img1, IMAGE img2, char* name);//背景二，点击暂停按钮后出现的界面，在原来的暂停处出现继续按钮

void playinggame(IMAGE img1, IMAGE img2, char* str);//游戏的执行

void paixu(int *a, int k);//对写入文件的数据进行排序

void get(FILE *fp, int *a, int n);//从文件fp中读取n个数据到数组a

int getinteger(FILE *fp);//获取文件中整数数椐的个数  

int main()
{
	//music();
	int i = 1;
	char name[10];
	initgraph(640, 480);
	IMAGE img1;
	loadimage(NULL, _T("1.jpg"), 100, 100);
	getimage(&img1, 0, 0, 100, 100);
	IMAGE img2;
	loadimage(NULL, _T("2.jpg"), 100, 100);
	getimage(&img2, 0, 0, 100, 100);
	GameCinematic2();
	Sleep(1000);
	GameCinematic1();
	Sleep(1000);
	GameCinematic3();
	huanying();
	hit(img1, img2, name);
	while (jiemian() == 1)
	{
		introduction();
	}
	playername(name);
	while (1) {
		if (i == 1) {

			background1(img1, img2, name);
			playinggame(img1, img2, name);
			i--;
		}
		if (MouseHit()) {
			MOUSEMSG k;
			k = GetMouseMsg();
			//重新开始
			if (k.x >= 0 && k.x <= 280 && k.y >= 380 && k.y <= 460)
			{

				if (k.uMsg == WM_LBUTTONDOWN) {
					i++;
				}

			}
			//残忍退出
			if (k.x >= 360 && k.x <= 640 && k.y >= 380 && k.y <= 460)
			{

				if (k.uMsg == WM_LBUTTONDOWN) {
					CLOSE();
					break;
				}
			}
		}
	}
	closegraph();
}

void introduction() {
	setbkmode(TRANSPARENT);
	setcolor(WHITE);
	IMAGE img3;
	loadimage(NULL, _T("13.jpg"), 640, 480, false);
	settextstyle(60, 0, _T("楷体"));
	outtextxy(180, 10, "游戏介绍");
	settextstyle(19, 0, _T("黑体"));
	ellipse(500, 440, 630, 475);
	outtextxy(20, 100, "游戏区的中间出现一道算术题，在0.5秒内点击勾或叉，答对得一分，");
	outtextxy(0, 150, "答错不得分，答完后自动显示下一题。超过0.5秒算答错自动进入下一题。");
	outtextxy(0, 200, "初始时有五道算术题，点一次“增加”按钮，就增加一道算术题在最后，");
	outtextxy(0, 250, "点“删除”按钮就把当前的算术题删掉，显示下一道算术题，");
	outtextxy(0, 300, "系统自动在最后增加一道算术题。答完所有题目后提示完成，");
	outtextxy(0, 350, "显示得分及排名。点“暂停”按钮，则答案不往下落了。");
	outtextxy(0, 400, "点“退出”按钮，则结束游戏，并把玩家姓名和所得分数写入文件中。");
	settextstyle(35, 0, _T("楷体"));
	outtextxy(530, 440, "返回");
	while (1) {
		if (MouseHit()) {
			MOUSEMSG k;
			k= GetMouseMsg();
			if (k.x >= 500 && k.x <= 630 && k.y >= 440 && k.y <= 480) {
				if (k.uMsg == WM_LBUTTONUP) {
					break;
				}
			}
		}
	}
}

int jiemian() {
	int i,j=0;
	setbkmode(TRANSPARENT);
	settextcolor(WHITE);
	setcolor(WHITE);
	IMAGE img3;
	loadimage(NULL, _T("9.jpg"), 640, 480, false);
	settextstyle(60, 0, _T("楷体"));
	outtextxy(170, 80, "算术小游戏");
	settextstyle(38, 0, _T("黑体"));
	ellipse(80, 180, 270, 260);
	ellipse(360, 180, 550, 260);
	ellipse(80, 280, 270, 360);
	ellipse(360, 280, 550, 360);
	ellipse(81, 181, 271, 261);
	ellipse(361, 181, 551, 261);
	ellipse(81, 281, 271, 361);
	ellipse(361, 281, 551, 361);
	ellipse(82, 182, 272, 262);
	ellipse(362, 182, 552, 262);
	ellipse(82, 282, 272, 362);
	ellipse(362, 282, 552, 362);
	outtextxy(100, 200,"打开音乐" );
	outtextxy(380, 200, "游戏介绍");
	outtextxy(100, 300, "开始游戏");
	outtextxy(380, 300, "退出游戏");
	while (1) {
		if (MouseHit()) {
			MOUSEMSG k;
			k = GetMouseMsg();
			//开始游戏
			if (k.x >= 80 && k.x <= 270 && k.y >= 280 && k.y <= 360) {
				if (k.uMsg == WM_LBUTTONUP) {
					j = 1;
					return 0;
				}
			}
			//直接退出
			if (k.x >= 360 && k.x <= 550 && k.y >= 280 && k.y <= 360) {
				if (k.uMsg == WM_LBUTTONUP) {
					CLOSE();
					exit(0);
				}
			}
			//打开音乐
			if (k.x >= 80 && k.x <= 270 && k.y >= 180 && k.y <= 260) {
				if (k.uMsg == WM_LBUTTONUP) {
					music();
					j = 1;
				}
			}
			//游戏介绍
			if (k.x >= 360 && k.x <= 550 && k.y >= 180 && k.y <= 260) {
				if (k.uMsg == WM_LBUTTONUP) {
					return 1;
				}
			}
		}
	}
	if (j == 1)
		return 0;
}

void hit(IMAGE img1, IMAGE img2, char* str3) {
	while (1) {
		if (MouseHit()) {
			MOUSEMSG k;
			k = GetMouseMsg();
			if (k.x >= 0 && k.x <= 640 && k.y >= 0 && k.y <= 480) {
				if (k.uMsg == WM_LBUTTONUP) {
					break;
				}
			}
		}
	}
}

void huanying() {
	IMAGE img3;
	loadimage(NULL, _T("11.jpg"), 640, 480, false);
	//getimage(&img3, 0, 0, 640, 480);
	settextcolor(WHITE);
	setbkmode(TRANSPARENT);
	settextstyle(80, 0, _T("楷体"));
	TCHAR s1[] = _T("欢迎来到");
	outtextxy(190, 150, s1);
	outtextxy(140, 230, "算术小游戏!");
}

void playername(char* z) {
	char name[10];
	initgraph(640, 480);
	cleardevice();
	settextcolor(WHITE);
	setbkmode(TRANSPARENT);
	loadimage(NULL, _T("11.jpg"), 640, 480);
	settextstyle(50, 0, _T("楷体"));
	TCHAR s1[] = _T("算术小游戏");
	outtextxy(200, 80, s1);
	InputBox(name, 10, "请输入你的姓名", "算术小游戏", "Player");
	for (int i = 0;i < 10;i++) {
		z[i] = name[i];
	}
}

void music() {
	mciSendString("open 欢沁.mp3 alias mymusic", NULL, 0, NULL);
	mciSendString("play 欢沁.mp3", NULL, 0, NULL);
}

void background1(IMAGE img1, IMAGE img2, char* a) {
	loadimage(NULL, _T("10.jpg"), 640, 480, false);
	IMAGE img3;
	getimage(&img3, 0, 0, 640, 480);
	putimage(0, 0, &img3);
	// 设置背景色为蓝色
	//setbkcolor(RGB(0,191,255));
	// 用背景色清空屏幕
	//cleardevice();
	// 设置绘图色为红色
	setcolor(WHITE);
	//setfillcolor(RGB(255,255,224));
	// 画矩形
	//rectangle(40, 50, 500, 430);
	ellipse(540, 85, 620, 135);
	//setfillcolor(RGB(176,226,255));
	ellipse(540, 155, 620, 205);
	//setfillcolor(RGB(255,187,255));
	ellipse(540, 225, 620, 275);
	//setfillcolor(RGB(255,225,255));
	ellipse(540, 295, 620, 345);
	//setfillcolor(YELLOW);
	//ellipse(540, 365, 620, 415);
	//line(520, 0, 520, 480);
	LOGFONT f;
	gettextstyle(&f);                     // 获取当前字体设置
	f.lfHeight = 25;                      // 设置字体高度为 25
	_tcscpy(f.lfFaceName, _T("黑体"));    // 设置字体为“黑体”(高版本 VC 推荐使用 _tcscpy_s 函数)
	f.lfQuality = ANTIALIASED_QUALITY;    // 设置输出效果为抗锯齿
	settextstyle(&f);  // 设置字体样式*/
	setbkmode(TRANSPARENT);
	TCHAR ch[] = _T("玩家姓名：");
	outtextxy(10, 80, ch);
	TCHAR str[50];
	_stprintf(str, _T("%s"), a);
	outtextxy(130, 80, str);
	outtextxy(10, 20, "玩家的得分：");
	outtextxy(558, 100, "暂停");
	outtextxy(558, 170, "增加");
	outtextxy(558, 240, "删除");
	outtextxy(558, 310, "退出");
	outtextxy(460, 20, "题目数量：");
	putimage(110, 320, &img2);
	putimage(340, 320, &img1);
}

void background2(IMAGE img1, IMAGE img2, char* a) {
	loadimage(NULL, _T("10.jpg"), 640, 480, false);
	IMAGE img3;
	getimage(&img3, 0, 0, 640, 480);
	putimage(0, 0, &img3);
	// 设置背景色为蓝色
	//setbkcolor(RGB(0,191,255));
	// 用背景色清空屏幕
	//cleardevice();
	// 设置绘图色为红色
	setcolor(WHITE);
	//setfillcolor(RGB(255,255,224));
	// 画矩形
	//rectangle(40, 50, 500, 430);
	ellipse(540, 85, 620, 135);
	//setfillcolor(RGB(176,226,255));
	ellipse(540, 155, 620, 205);
	//setfillcolor(RGB(255,187,255));
	ellipse(540, 225, 620, 275);
	//setfillcolor(RGB(255,225,255));
	ellipse(540, 295, 620, 345);
	//setfillcolor(YELLOW);
	//ellipse(540, 365, 620, 415);
	//line(520, 0, 520, 480);
	LOGFONT f;
	gettextstyle(&f);                     // 获取当前字体设置
	f.lfHeight = 25;                      // 设置字体高度为 25
	_tcscpy(f.lfFaceName, _T("黑体"));    // 设置字体为“黑体”(高版本 VC 推荐使用 _tcscpy_s 函数)
	f.lfQuality = ANTIALIASED_QUALITY;    // 设置输出效果为抗锯齿  
	settextstyle(&f);  // 设置字体样式*/
	setbkmode(TRANSPARENT);
	TCHAR ch[] = _T("玩家姓名：");
	outtextxy(10, 80, ch);
	TCHAR str[50];
	_stprintf(str, _T("%s"), a);
	outtextxy(130, 80, str);
	outtextxy(10, 20, "玩家的得分：");
	outtextxy(558, 100, "继续");
	outtextxy(558, 170, "增加");
	outtextxy(558, 240, "删除");
	outtextxy(558, 310, "退出");
	outtextxy(460, 20, "题目数量：");
	putimage(110, 320, &img2);
	putimage(340, 320, &img1);
}

void playinggame(IMAGE img1, IMAGE img2, char* g) {
	clock_t start, end;
	start = clock();
	time_t  t1, t2;
	int second = 0, minute = 0, hour = 0;
	int interval;
	t1 = time(NULL);
	int a, b, c, d;
	int i = 1;
	int x = 0, y = 0;
	int z = 1;
	char s;
	char s1[] = { '+', '-', '*', '/' };
	node *head = NULL;
	node *p, *rear, *pre, *add;
	srand((unsigned)time(NULL));
	while (1)
	{
		p = (node*)malloc(sizeof(node));
		p->m = GEN_VALUE1();
		p->n = GEN_VALUE();
		p->v = s1[GEN_VALUE2()];
		if (p->v == '/' &&p->m%p->n != 0)
			continue;
		i++;
		if (head == NULL)
		{
			head = p;
			rear = p;
		}
		else {
			rear->next = p;
			rear = p;
		}
		if (i == 12)
			break;
	}
	p = head;
	d = GEN_VALUE3();
	TCHAR str[50];
	_stprintf(str, _T("%d"), x);
	outtextxy(150, 20, str);
	int k;
	for (pre = p;pre->next != p;)
	{
		k = i - 2;
		if (k == 0) {
			break;
		}
		switch (pre->v)
		{
		case '+': a = (float)pre->m + (float)pre->n; break;
		case '-': a = (float)pre->m - (float)pre->n; break;
		case '*': a = (float)pre->m * (float)pre->n; break;
		case '/': a = (float)pre->m / (float)pre->n; break;
		}
		switch (s1[d])
		{
		case '+': c = (float)pre->m + (float)pre->n; break;
		case '-': c = (float)pre->m - (float)pre->n; break;
		case '*': c = (float)pre->m * (float)pre->n; break;
		case '/': c = (float)pre->m / (float)pre->n; break;
		}
		settextstyle(50, 0, _T("楷体"));
		TCHAR str[50];
		_stprintf(str, _T("%d"), pre->m);
		outtextxy(160, 140, str);
		outtextxy(260, 140, pre->v);
		TCHAR str2[50];
		_stprintf(str2, _T("%d"), pre->n);
		outtextxy(360, 140, str2);
		TCHAR str3[50];
		_stprintf(str3, _T("%d"), a);
		outtextxy(300, 210, "=");
		//outtextxy(260, 190, str3);
		TCHAR str4[50];
		_stprintf(str4, _T("%d"), c);
		outtextxy(360, 210, str4);
		settextstyle(25, 0, _T("黑体"));
		TCHAR str5[50];
		_stprintf(str5, _T("%d"), x);
		outtextxy(150, 20, str5);
		TCHAR str6[50];
		_stprintf(str6, _T("%d"), k);
		outtextxy(600, 20, str6);
		t2 = time(NULL);

		interval = t2 - t1;
		//计时开始
		if (interval == 1 && y == 0) {
			second++;
			t1 = t2;
			background1(img1, img2, g);
		}
		//判断是否到了0.5秒，如果超过0.5秒就跳过当前的题目
		end = clock();
		if (((double)end - start) / CLK_TCK == 3 && y == 0) {
			start = end;
			i--;
			pre = pre->next;
			background1(img1, img2, g);
		}

		if (((double)end - start) / CLK_TCK == 3) {
			start = end;
		}
		if (interval == 1) {
			t1 = t2;
		}
		if (second == 60) {
			minute++;
			second = 0;
		}
		if (minute== 60) {
			hour++;
			minute = 0;
		}
		if (hour == 24) {
			hour = 0;
		}
		outtextxy(240, 20, "时间:");
		TCHAR str10[50];
		_stprintf(str10, _T("%02d"), second);
		outtextxy(400, 20, str10);
		TCHAR str11[50];
		_stprintf(str11, _T("%02d:"), minute);
		outtextxy(360, 20, str11);
		TCHAR str12[50];
		_stprintf(str12, _T("%02d:"), hour);
		outtextxy(320, 20, str12);
		if (MouseHit()) {
			MOUSEMSG k;
			k = GetMouseMsg();
			//获取“答案正确”的鼠标信息
			if (k.x >= 110 && k.x <= 210 && k.y >= 320 && k.y <= 420)
			{

				if (k.uMsg == WM_LBUTTONDOWN && y == 0) {
					if (a == c) {
						x++;
					}
					else {
						//x--;
					}
					if (y == 1) {
						background2(img1, img2, g);
					}
					else {

						background1(img1, img2, g);
					}
					i--;
					TCHAR str[50];
					_stprintf(str, _T("%d"), x);
					outtextxy(150, 20, str);
					pre = pre->next;
					d = GEN_VALUE3();

				}

			}
			//获取“答案错误”的鼠标信息
			if (k.x >= 340 && k.x <= 440 && k.y >= 320 && k.y <= 420)
			{

				if (k.uMsg == WM_LBUTTONDOWN && y == 0) {
					if (a != c) {
						x++;
					}
					else {
						//x--;
					}
					if (y == 1) {

						background2(img1, img2, g);
					}
					else {

						background1(img1, img2, g);
					}
					i--;

					TCHAR str[50];
					_stprintf(str, _T("%d"), x);
					outtextxy(150, 20, str);
					pre = pre->next;
					d = GEN_VALUE3();

				}

			}
			//获取“删除”的鼠标信息
			if (k.x >= 540 && k.x <= 620 && k.y >= 225 && k.y <= 275) {
				if (k.uMsg == WM_LBUTTONDOWN) {
					if (y == 1) {

						background2(img1, img2, g);
					}
					else {
						background1(img1, img2, g);
					}
					i--;
					pre = pre->next;

				}
			}
			//获取“退出”的鼠标信息
			if (k.x >= 540 && k.x <= 620 && k.y >= 295 && k.y <= 345) {
				if (k.uMsg == WM_LBUTTONDOWN) {
					break;
				}
			}
			//获取“继续”的鼠标信息
			if (k.x >= 540 && k.x <= 620 && k.y >= 85 && k.y <= 135) {
				if (k.uMsg == WM_LBUTTONUP) {
					y = 1;//处于暂停界面

					background2(img1, img2, g);

				}
			}
			//获取“暂停”的鼠标信息
			if (k.x >= 540 && k.x <= 620 && k.y >= 85 && k.y <= 135) {

				if (k.uMsg == WM_RBUTTONUP && y == 1) {
					y = 0;//处于继续界面
					background1(img1, img2, g);
				}
			}
			//获取“增加”的鼠标信息
			if (k.x >= 540 && k.x <= 620 && k.y >= 155 && k.y <= 205) {
				if (k.uMsg == WM_LBUTTONDOWN) {
					add = (node*)malloc(sizeof(node));
					add->m = GEN_VALUE1();
					add->n = GEN_VALUE();
					add->v = s1[GEN_VALUE2()];
					rear->next = add;
					rear = add;
					if (y == 1) {

						background2(img1, img2, g);
					}
					else {

						background1(img1, img2, g);
					}
					i++;
				}
			}

		}
	}
	//显示出游戏结束界面，并得出玩家的得分
	loadimage(NULL, _T("12.jpg"), 640, 480);
	setcolor(WHITE);
	settextstyle(60, 0, _T("楷体"));
	outtextxy(150, 10, "您的总用时：");
	int T = hour * 3600 + minute * 60 + second;
	TCHAR str13[50];
	_stprintf(str13, _T("%d"), T);
	outtextxy(480, 10,str13);
	outtextxy(550, 10, "s");
	TCHAR s15[] = _T("游戏结束");
	outtextxy(150, 220, s15);
	TCHAR s10[] = _T("得分：");
	outtextxy(150, 80, s10);
	TCHAR str11[50];
	_stprintf(str11, _T("%d"), x);
	outtextxy(310, 80, str11);
	ellipse(0, 380, 280, 460);
	ellipse(360, 380, 640, 460);
	ellipse(1, 381, 281, 461);
	ellipse(361, 381, 641, 461);
	ellipse(2, 382, 282, 462);
	ellipse(362, 382, 642, 462);
	outtextxy(20, 387, "重新开始");
	outtextxy(380, 387, "残忍退出");
	int h1, h2, h3;
	FILE *f,*fp;
	int *L;
	TCHAR score[5];
	_stprintf(score, _T("%d"), x);//将数字x的值转换成数组的形式
	f = fopen("scores", "a+");//打开已建立的文件追加数据
	fp = fopen("player&scores", "a+");
	char str12[] = "玩家：";
	fputs(str12, fp);
	fputs(g, fp);
	char str17[] = "\n";
	fputs(str17, fp);
	char str18[] = "得分：";
	fputs(str18, fp);
	fputs(score, fp);
	char str16[] = "\n\n";
	fputs(str16, fp);
	fclose(fp);
	fputs(score,f);//向文件中写入数据；
	char str14[] = "  ";
	fputs(str14, f);
	h1 = getinteger(f);//获取文件中整数数椐的个数  
	L= (int *)malloc(sizeof(int)*h1);
	get(f, L, h1);//从文件fp中读取h1个数据到数组L
	fclose(f);
	paixu(L, h1);//对写入文件的数据进行排序
	for (h2 = 0; L[h2] != x; h2++);
	outtextxy(150, 150, "您的排名：");
	h3 = h2 + 1;
	TCHAR h4[5];
	_stprintf(h4, _T("%d"), h3);
	outtextxy(430, 150, h4);//输出排名
	settextstyle(40, 0, _T("楷体"));
	outtextxy(320, 320, "Player:");
	outtextxy(460, 320, g);
}

void paixu(int *a, int k) {
	int i, j, m;
	for (i = 0; i < k - 1; i++)
		for (j = i + 1; j < k; j++)
			if (a[i] < a[j]) {
				m = a[i]; a[i] = a[j]; a[j] = m;
			}
}

void get(FILE *fp, int *a, int n) {
	int j;
	fseek(fp, 0, 0);
	for (j = 0; j < n; j++) {
		fscanf(fp, "%d", &a[j]);
	}
}

int getinteger(FILE *fp) {
	int j = 0, n;
	fseek(fp, 0, 0);
	while (fscanf(fp, "%d", &n) != EOF) {
		j++;
	}
	return j;
}

void GameCinematic1() {
	IMAGE bkimg;
	loadimage(&bkimg, "16.jpg", WIDTH, LENGTH, false);
	printf("%d\n%d\n%d\n%d\n", xA, yA, xB, yB);
	BeginBatchDraw();
	for (int i = 0; i < limit; i += 3) {
		POINT pts[] = { {xA - i, yA - i},{WIDTH, 0} , {xB + i,yB + i}, {0,LENGTH} };
		HRGN KK = CreatePolygonRgn(pts, 4, ALTERNATE);
		setcliprgn(KK);
		putimage(0, 0, &bkimg);
		FlushBatchDraw();
		DeleteObject(KK);
		if (i <= 60) { Sleep(15); }
		if (i >= 60 && i <= 150) { Sleep(8); }
		if (i >= 150) { Sleep(4); }
	}
	EndBatchDraw();
	printf("%d\n%d\n%d\n%d\n", xA - limit, yA - limit, xB + limit, yB + limit);
}

void GameCinematic2() {
	BeginBatchDraw();
	for (int i = 0; i < limit; i += 3) {
		POINT pts[] = { {0 + i,0 + i},{WIDTH, 0} , { WIDTH - i,LENGTH - i}, {0,LENGTH} };
		HRGN KK = CreatePolygonRgn(pts, 4, ALTERNATE);
		setcliprgn(KK);
		if (i <= 200) { setbkcolor(RGB(3 * i, 0,i/3)); }//参数值越大色彩
		if (i >= 300 && i <= 400) { setbkcolor(RGB(6 * i, 0,i/6)); }
		cleardevice();
		FlushBatchDraw();
		DeleteObject(KK);
		if (i <= 60) { Sleep(15); }

		if (i >= 60 && i <= 150) { Sleep(8); }

		if (i >= 150) { Sleep(4); }

		/////Sleep(100);
	}
	EndBatchDraw();
}

void GameCinematic3() {
	IMAGE bkimg;
	loadimage(&bkimg, "5.jpg", WIDTH, LENGTH, false);
	BeginBatchDraw();
	setfillcolor(RGB(0, 255, 255));
	for (int i = 0; i < limit; i += 5) {
		POINT pts[] = { {i,i},{WIDTH, 0} , {WIDTH - i,LENGTH - i}, {0,LENGTH} };
		putimage(0, 0, &bkimg);
		solidpolygon(pts, 4);
		FlushBatchDraw();
		if (i <= 60) { Sleep(15); }

		if (i >= 60 && i <= 150) { Sleep(8); }

		if (i >= 150) { Sleep(4); }

	}
	putimage(0, 0, &bkimg);
	EndBatchDraw();

}

void CLOSE() {
	loadimage(&bkimg, "14.jpg", WIDTH, LENGTH, false);
	putimage(0, 0, &bkimg);
	BeginBatchDraw();
	setlinecolor(RGB(0, 0, 0));
	setfillcolor(RGB(0, 0, 0));
	for (int i = 0; i < limit; i++) {
		POINT pts[] = { {i,i},{WIDTH, 0} , {WIDTH - i,LENGTH - i}, {0,LENGTH} };
		polygon(pts, 4);
		FlushBatchDraw();
		if (i <= 60) { Sleep(3); }

		if (i >= 60 && i <= 150) { Sleep(2); }

		if (i >= 150) { Sleep(1); }
	}
	setbkcolor(BLACK);
	cleardevice();
	EndBatchDraw();

}